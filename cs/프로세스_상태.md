운영체제에서 프로세스는 단순히 “만들고 실행하는 객체”가 아니다.
프로세스는 다음과 같은 **명확한 생애주기(Lifecycle)**를 가진다.

생성 → 준비 → 실행 → 대기 ↔ 준비 → 종료 → 좀비 → 해제

이 흐름 속에서 커널이 실제로 어떤 일을 하는지 하나씩 살펴보자.

1️⃣ 생성(Create) — PID 확보, PCB 생성, Ready Queue 등록

커널은 새 프로세스를 만들기 위해 먼저 빈 PID가 있는지 확인해야 한다.
PID가 수만 개가 넘는 환경에서 매번 전체를 훑는 것은 불가능하므로,
커널은 비트맵(Bitmask) 알고리즘을 사용해 빈 번호인지 즉시 판별한다.

PID가 확정되면 다음이 생성된다:

PCB(Process Control Block)

커널 스택

메모리 매핑 정보

스케줄러에 넘길 각종 메타데이터

이 모든 준비가 끝나야만 프로세스는 Ready Queue에 등록되고 실행 자격을 얻는다.

2️⃣ 준비(Ready) — 아무 일도 하지 않는 대기 상태

Ready 상태의 프로세스는 CPU를 기다릴 뿐, 어떤 일도 하지 않는다.
대기열에 세워진 차량처럼 멈춘 채 기다리는 상태이다.

하지만 “영원히 대기”하는 경우는 존재하지 않는다.
현대 OS는 이를 방지하기 위해 다음을 사용한다:

Aging(윈도우) — 오래 기다릴수록 우선순위를 올림

CFS(리눅스) — CPU를 덜 쓴 프로세스를 우선 배정

타임슬라이스 균등 배분 — 너무 오래 독점하지 못하게 균등한 CPU 사용 시간 제공

즉, 어떤 방식이든 결국 모든 프로세스가 언젠가는 반드시 CPU를 받는다.

3️⃣ 실행(Running) — 스케줄링 정책에 따라 CPU 배정

스케줄러는 “누구를 먼저 CPU에 올릴지”를 결정한다.
이때 스케줄링은 시간표 운영이 아니라, 순서 결정 로직이다.

대표 스케줄링 방식은 5가지다:

FCFS: 먼저 온 순서대로 실행 → 단순하지만 호위 효과 발생

RR: 동일한 시간 단위로 돌아가며 실행 → 공정하지만 컨텍스트 스위칭 과도

우선순위: 중요도를 기준으로 선택 → 잘못 설계하면 기아(starvation) 발생

SJF: 이론상 완벽 / 실행 시간이 짧은 것부터 실행 → 실행시간을 미리 알 수 없어 실전 불가

CFS: CPU 사용량이 적은 프로세스부터 실행 → 공정성은 최고, 처리량은 다소 손해

각 스케줄러는 FCFS와 RR을 기반으로 진화하며 각각 다른 철학을 가진다.

➡ 윈도우는 우선순위 + RR 혼합형
➡ 리눅스는 CFS 선택
➡ 이 둘의 목표가 완전히 다르기 때문

4️⃣ 종료(Exit) → 좀비(Zombie) → 해제(Removal)

프로세스가 일을 끝냈다고 바로 사라지는 건 아니다.

Exit: 실행은 끝났지만 리소스 회수는 아직

Zombie: PCB만 남아서 부모 프로세스의 회수를 기다리는 상태

Removal: 부모가 wait() 해서 정보를 수거하면 완전히 메모리에서 제거됨

즉, 종료는 “완전한 소멸”이 아니라 해제를 위한 중간 단계라고 보면 된다.
