# 🧠 OS 첫 번째: 프로세스와 스레드

## 📌 들어가며
운영체제를 이해하기 위한 첫걸음은 **프로세스(Process)** 와 **스레드(Thread)** 개념을 명확히 구분하는 것이다.  
이 둘은 프로그램이 ‘어떻게 실행되는가’를 결정하는 핵심 단위이며,  
레디스의 싱글 스레드 모델이나 자바의 멀티스레드 동작처럼 다양한 기술의 근간이 된다.

---

## 🏭 1. 프로세스 (Process)

### 💡 정의
> 실행 중인 프로그램으로, 독립된 메모리 공간을 가진 실행 단위.

### 📦 특징
- Code, Data, Heap, Stack 영역으로 구성됨
- 각 프로세스는 **PID(Process ID)** 로 구분됨
- 자식 프로세스 종료 시 `wait()` 호출을 통해 PID 회수 필요  
  → 회수되지 않으면 **Zombie Process** 상태 발생

### ⚙️ 프로세스 상태
| 상태 | 설명 |
|------|------|
| Running | 실행 중 |
| Waiting | 대기 중 |
| Terminated | 종료 완료 |
| Zombie | 실행은 끝났지만 PCB가 남아있는 상태 |

### 🧱 커널 (Kernel)
- 하드웨어 접근을 통제하는 **운영체제의 핵심 두뇌**
- 모든 프로세스는 하드웨어에 직접 접근하지 않고 커널을 통해 요청
- 보안성과 안정성을 보장하기 위한 중재자 역할

---

## ⚡ 2. 멀티프로세싱 (Multiprocessing)

### 💡 정의
여러 개의 프로세스를 동시에 실행하는 기술

### 🔍 병렬 구조 구분
| 구분 | 의미 | 특징 |
|------|------|------|
| 물리적 병렬 (Parallelism) | 여러 코어가 동시에 실행 | 실제 병렬 수행 |
| 논리적 병렬 (Concurrency) | 하나의 코어가 빠르게 교체 실행 | 동시에 보이게 하는 착시 |

### ⚙️ 핵심 개념
- **시분할 (Time Sharing)** : CPU 시간을 분할하여 여러 프로세스에게 할당  
- **컨텍스트 스위칭 (Context Switching)** : 프로세스 전환 시 상태 저장/복원

---

## 🔗 3. 프로세스 간 통신 (IPC: Inter-Process Communication)

| 방식 | 커널 관여 | 방향 | 속도 | 난이도 | 대표 예시 |
|------|------------|------|------|--------|------------|
| Pipe | O | 단방향 | 중간 | 쉬움 | 부모-자식 간 통신 |
| Message Queue | O | 양방향(논리) | 중간 | 중간 | 데몬 간 메시지 교환 |
| Shared Memory | O(초기만) | 양방향 | 🔥 가장 빠름 | 어려움(락 필요) | DB 캐시 |
| Socket | O | 양방향 | 중간~빠름 | 중간 | 클라이언트/서버 통신 |

> 💬 RabbitMQ, Kafka의 “Message Queue”는 IPC의 확장된 개념이며, 완전히 같은 용어는 아님.

---

## 🧵 4. 스레드 (Thread)

### 💡 정의
> 프로세스 내에서 실제로 작업을 수행하는 실행 단위.

### 🧠 비유
프로세스 = 병원(건물)  
스레드 = 의사, 간호사(일꾼)

### 🧩 메모리 구조
| 영역 | 스레드 간 공유 | 설명 |
|------|----------------|------|
| Code | ✅ | 실행 코드 공유 |
| Data | ✅ | 전역/정적 변수 공유 |
| Heap | ✅ | 동적 메모리 공유 |
| Stack | ❌ | 스레드 고유의 지역 변수 및 호출 정보 |

---

## 🔀 5. 멀티스레드 (Multi-Thread)

| 용어 | 의미 |
|------|------|
| 멀티스레딩 | 하나의 프로세스에서 여러 스레드를 실행하는 기법 |
| 멀티스레드 | 여러 스레드가 동시에 실행 중인 상태 |

### 📈 특징
- 메모리 효율성 높음 (자원 공유)
- 동기화 문제 발생 가능 (경쟁 조건 발생)

---

## 🧩 6. 동기화 (Synchronization)

> 여러 스레드가 공유 자원에 접근할 때 **데이터의 일관성과 실행 순서**를 보장하는 제어 기법.

### ⚠️ 경쟁 조건 (Race Condition)
여러 스레드가 동시에 동일 자원에 접근하여 실행 결과가 예측 불가한 상태

### 🧱 3대 조건
| 조건 | 의미 | 예시 |
|------|------|------|
| 원자성 (Atomicity) | 나눌 수 없는 최소 연산 단위 | CAS(Compare-And-Swap) |
| 순서성 (Ordering) | 실행 순서 제어 | Mutex, Semaphore |
| 가시성 (Visibility) | 한 스레드의 변경이 다른 스레드에게도 보임 | volatile, memory barrier |

### 🔒 락(Lock) 종류
| 이름 | 특징 |
|------|------|
| Mutex | 한 번에 하나만 접근 가능 |
| Semaphore | N개까지 동시 접근 허용 |

---

## 🧰 7. Thread-Safe

> 여러 스레드가 동시에 접근해도 결과가 깨지지 않는 코드 상태.

- 경쟁 조건(Race Condition) 없이 동작
- 원자성, 순서성, 가시성이 모두 지켜진 상태
- 즉, 완벽한 동기화가 이루어진 상태

---

## 🧩 8. 핵심 정리

| 구분 | 프로세스 | 스레드 |
|------|-----------|---------|
| 메모리 | 독립적 공간 | 공유 공간 |
| 통신 | IPC 필요 | 공유 자원 직접 접근 |
| 안정성 | 높음 | 낮음 |
| 효율성 | 낮음 | 높음 |
| 생성 비용 | 높음 | 낮음 |

---

## 🚀 결론

- **프로세스**는 안정성과 독립성이 강점  
- **스레드**는 효율성과 반응성이 강점  
- **멀티프로세싱**은 병렬성, **멀티스레딩**은 동시성에 초점  
- **동기화**는 멀티스레드 환경의 필수 제어 메커니즘  

결국, **원자성·순서성·가시성**을 지켜야 진짜 멀티스레드 환경에서 안전하게 동작한다.

---

## 📚 Reference
- Operating System Concepts – Silberschatz et al.  
- Modern Operating Systems – Andrew Tanenbaum  
- [Red Hat Developer Docs: Process vs Thread](https://developers.redhat.com/articles/2021/03/09/threads-vs-processes)  
- [Oracle Java Docs: Thread Safety](https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html)
- [Process vs Thread](https://b-programmer.tistory.com/480)
